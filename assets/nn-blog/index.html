<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Transformation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, points;
        let networkData = null;
        let currentLayerIndex = 0;
        let animationProgress = 0;
        let animationSpeed = 2;
        let pointsGeometry, pointsMaterial;
        let originalPositions = [];
        let targetPositions = [];
        let defaultFiles = ['leaky_relu_network_data.json', 'tanh_network_data.json'];
        let currentFileIndex = 0;
        let isWaiting = false;
        let waitStartTime = 0;

        function getLayerName(index, total) {
            if (index === 0) return 'Input Layer';
            if (index === total - 1) return 'Output Layer';
            return `Hidden Layer ${index}`;
        }

        function initScene() {
            const container = document.getElementById('container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const axesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            const axesGeometry = new THREE.BufferGeometry();
            const axesVertices = new Float32Array([
                0, 0, 0,  4, 0, 0,
                0, 0, 0,  0, 4, 0,
                0, 0, 0,  0, 0, 4
            ]);
            axesGeometry.setAttribute('position', new THREE.BufferAttribute(axesVertices, 3));
            const axesHelper = new THREE.LineSegments(axesGeometry, axesMaterial);
            scene.add(axesHelper);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const gridHelper = new THREE.GridHelper(8, 8, 0x999999, 0x999999);
            scene.add(gridHelper);

            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
                    const axis = new THREE.Vector3(1, 0, 0);
                    axis.applyQuaternion(camera.quaternion);
                    camera.position.applyAxisAngle(axis, deltaY * 0.01);
                    
                    camera.lookAt(0, 0, 0);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const direction = e.deltaY > 0 ? 1 : -1;
                camera.position.multiplyScalar(1 + direction * zoomSpeed);
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createPoints(data) {
            if (points) {
                scene.remove(points);
                pointsGeometry.dispose();
                pointsMaterial.dispose();
            }

            const positions = [];
            const colors = [];

            const color1 = new THREE.Color(0x3b82f6);
            const color2 = new THREE.Color(0xef4444);

            data.points.forEach((point, i) => {
                positions.push(point[0], point[1], point[2] || 0);
                
                const color = data.labels[i] === 0 ? color1 : color2;
                colors.push(color.r, color.g, color.b);
            });

            pointsGeometry = new THREE.BufferGeometry();
            pointsGeometry.setAttribute('position', 
                new THREE.Float32BufferAttribute(positions, 3));
            pointsGeometry.setAttribute('color', 
                new THREE.Float32BufferAttribute(colors, 3));

            pointsMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                sizeAttenuation: true
            });

            points = new THREE.Points(pointsGeometry, pointsMaterial);
            scene.add(points);

            originalPositions = positions.slice();
        }

        function loadNetworkData(data) {
            networkData = data;
            createPoints(networkData);
            currentLayerIndex = 0;
        }

        function loadFileFromURL(url) {
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    loadNetworkData(data);
                    currentLayerIndex = 0;
                    animationProgress = 0;
                    prepareTransition(currentLayerIndex, currentLayerIndex + 1);
                
                })
                .catch(err => {
                    console.error('Error loading file:', err);
                });
        }

        function prepareTransition(fromLayer, toLayer) {
            if (!networkData) return;

            const fromActivations = networkData.activations[fromLayer];
            const toActivations = networkData.activations[toLayer];
            
            originalPositions = [];
            targetPositions = [];

            fromActivations.forEach((fromAct, i) => {
                const toAct = toActivations[i];
                
                originalPositions.push(
                    fromAct[0] || 0,
                    fromAct[1] || 0,
                    fromAct[2] || 0
                );
                
                targetPositions.push(
                    toAct[0] || 0,
                    toAct[1] || 0,
                    toAct[2] || 0
                );
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isWaiting) {
                if (Date.now() - waitStartTime >= 1000) {
                    isWaiting = false;
                    currentFileIndex = (currentFileIndex + 1) % defaultFiles.length;
                    loadFileFromURL(defaultFiles[currentFileIndex]);
                }
            } else if (networkData) {
                animationProgress += 0.01 * animationSpeed;
                
                if (animationProgress >= 1) {
                    animationProgress = 0;
                    currentLayerIndex++;
                    
                    if (currentLayerIndex >= networkData.activations.length - 1) {
                        isWaiting = true;
                        waitStartTime = Date.now();
                    } else {
                        prepareTransition(currentLayerIndex, currentLayerIndex + 1);
                    }
                } else {
                    const positions = pointsGeometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i++) {
                        positions[i] = originalPositions[i] * (1 - animationProgress) + 
                                      targetPositions[i] * animationProgress;
                    }
                    pointsGeometry.attributes.position.needsUpdate = true;
                    
                    const progress = ((currentLayerIndex + animationProgress) / 
                                    (networkData.activations.length - 1)) * 100;
                }
            }

            renderer.render(scene, camera);
        }

        initScene();
        animate();
        loadFileFromURL(defaultFiles[0]);
    </script>
</body>
</html>
